<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Send comments to: Tony T (adthral)">

<title>14&nbsp; Graph Theory for Machine Learning – EDA for Machine Learning</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./em-algorithm.html" rel="next">
<link href="./ts-fourier.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-364982630eef5352dd1537128a8ed5cb.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./graph-theory.html">Graph Theory</a></li><li class="breadcrumb-item"><a href="./graph-theory.html"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Graph Theory for Machine Learning</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">EDA for Machine Learning</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/tthrall/eda4ml/" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Welcome</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./preface.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Statistics</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./eda.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Exploratory Data Analysis</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./conditioning.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Conditional Distributions</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./clustering.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Clustering: EDA in Higher Dimensions</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./simulation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Statistical Simulation</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./study-design.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Sampling and Study Design</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">Linear Algebra</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./la-intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Some Linear Algebra</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./reduce-dim.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Dimension Reduction</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true">
 <span class="menu-text">Text Data</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./text-analysis.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Text Analysis</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./dirichlet-dstn.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">The Dirichlet Distribution</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./latent-dirichlet-alloc.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Latent Dirichlet Allocation</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="true">
 <span class="menu-text">Time Series Data</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ts-intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Time Series Data Analysis</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ts-forecast.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Time Series Forecasting</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ts-fourier.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Time Series Spectrum Analysis</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="true">
 <span class="menu-text">Graph Theory</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./graph-theory.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Graph Theory for Machine Learning</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" role="navigation" aria-expanded="true">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-6" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./em-algorithm.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">EM: the Expectation-Maximization Algorithm</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./summary.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Summary</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#types-of-data-in-which-graphs-arise" id="toc-types-of-data-in-which-graphs-arise" class="nav-link active" data-scroll-target="#types-of-data-in-which-graphs-arise"><span class="header-section-number">14.1</span> Types of Data in which Graphs Arise</a>
  <ul class="collapse">
  <li><a href="#transaction-examples" id="toc-transaction-examples" class="nav-link" data-scroll-target="#transaction-examples"><span class="header-section-number">14.1.1</span> Transaction examples</a></li>
  <li><a href="#relationship-examples" id="toc-relationship-examples" class="nav-link" data-scroll-target="#relationship-examples"><span class="header-section-number">14.1.2</span> Relationship examples</a></li>
  </ul></li>
  <li><a href="#glossary-of-basic-terms" id="toc-glossary-of-basic-terms" class="nav-link" data-scroll-target="#glossary-of-basic-terms"><span class="header-section-number">14.2</span> Glossary of Basic Terms</a></li>
  <li><a href="#properties" id="toc-properties" class="nav-link" data-scroll-target="#properties"><span class="header-section-number">14.3</span> Properties</a>
  <ul class="collapse">
  <li><a href="#matrix-representations" id="toc-matrix-representations" class="nav-link" data-scroll-target="#matrix-representations"><span class="header-section-number">14.3.1</span> Matrix Representations</a></li>
  <li><a href="#betweenness-centrality" id="toc-betweenness-centrality" class="nav-link" data-scroll-target="#betweenness-centrality"><span class="header-section-number">14.3.2</span> Betweenness centrality</a></li>
  <li><a href="#connected-components" id="toc-connected-components" class="nav-link" data-scroll-target="#connected-components"><span class="header-section-number">14.3.3</span> Connected components</a></li>
  <li><a href="#communities" id="toc-communities" class="nav-link" data-scroll-target="#communities"><span class="header-section-number">14.3.4</span> Communities</a></li>
  <li><a href="#modularity" id="toc-modularity" class="nav-link" data-scroll-target="#modularity"><span class="header-section-number">14.3.5</span> Modularity</a></li>
  </ul></li>
  <li><a href="#algorithms-general" id="toc-algorithms-general" class="nav-link" data-scroll-target="#algorithms-general"><span class="header-section-number">14.4</span> Algorithms: General</a>
  <ul class="collapse">
  <li><a href="#page-rank" id="toc-page-rank" class="nav-link" data-scroll-target="#page-rank"><span class="header-section-number">14.4.1</span> Page Rank</a></li>
  <li><a href="#floyd-warshall" id="toc-floyd-warshall" class="nav-link" data-scroll-target="#floyd-warshall"><span class="header-section-number">14.4.2</span> Floyd-Warshall</a></li>
  <li><a href="#dijkstra" id="toc-dijkstra" class="nav-link" data-scroll-target="#dijkstra"><span class="header-section-number">14.4.3</span> Dijkstra</a></li>
  <li><a href="#brandes" id="toc-brandes" class="nav-link" data-scroll-target="#brandes"><span class="header-section-number">14.4.4</span> Brandes</a></li>
  </ul></li>
  <li><a href="#algorithms-clustering" id="toc-algorithms-clustering" class="nav-link" data-scroll-target="#algorithms-clustering"><span class="header-section-number">14.5</span> Algorithms: Clustering</a>
  <ul class="collapse">
  <li><a href="#girvan-newman" id="toc-girvan-newman" class="nav-link" data-scroll-target="#girvan-newman"><span class="header-section-number">14.5.1</span> Girvan-Newman</a></li>
  <li><a href="#spectral-clustering" id="toc-spectral-clustering" class="nav-link" data-scroll-target="#spectral-clustering"><span class="header-section-number">14.5.2</span> Spectral clustering</a></li>
  <li><a href="#clauset-newman-moore" id="toc-clauset-newman-moore" class="nav-link" data-scroll-target="#clauset-newman-moore"><span class="header-section-number">14.5.3</span> Clauset-Newman-Moore</a></li>
  <li><a href="#louvain" id="toc-louvain" class="nav-link" data-scroll-target="#louvain"><span class="header-section-number">14.5.4</span> Louvain</a></li>
  <li><a href="#leiden" id="toc-leiden" class="nav-link" data-scroll-target="#leiden"><span class="header-section-number">14.5.5</span> Leiden</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/tthrall/eda4ml/edit/main/graph-theory.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/tthrall/eda4ml/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./graph-theory.html">Graph Theory</a></li><li class="breadcrumb-item"><a href="./graph-theory.html"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Graph Theory for Machine Learning</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Graph Theory for Machine Learning</span></h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Send comments to: Tony T (adthral) </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">20:51 Tue 14-Oct-2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<hr>
<p>In mathematics and computer science, <em>graph theory</em> is the study of graphs, which are mathematical structures used to model pairwise relations between objects. A graph in this context is made up of <em>vertices</em> (also called nodes or points) which are connected by <em>edges</em> (also called arcs, links or lines). A distinction is made between <em>undirected</em> graphs, where edges link two vertices symmetrically, and <em>directed</em> graphs, where edges link two vertices asymmetrically. <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<section id="types-of-data-in-which-graphs-arise" class="level2" data-number="14.1">
<h2 data-number="14.1" class="anchored" data-anchor-id="types-of-data-in-which-graphs-arise"><span class="header-section-number">14.1</span> Types of Data in which Graphs Arise</h2>
<section id="transaction-examples" class="level3" data-number="14.1.1">
<h3 data-number="14.1.1" class="anchored" data-anchor-id="transaction-examples"><span class="header-section-number">14.1.1</span> Transaction examples</h3>
<p>Suppose <span class="math inline">\(A\)</span> contacts or pays <span class="math inline">\(B\)</span>, where the <em>nodes</em> <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are people (or perhaps software functions). The edge connecting <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> might be labeled “contact” or “pay”, in which case we need to distinguish whose contacting or paying whom. That information is given by the <em>direction</em> of the edge.</p>
<p>On the other hand, suppose we have just two types of node: people and products. And we have just one type of edge, say, “purchase”. Thus person <span class="math inline">\(A\)</span> purchases product <span class="math inline">\(B\)</span>. The subject-object relationship is evident from the distinct types of node. Then the “A-B” connection could just as well be read as: <span class="math inline">\(B\)</span> is purchased by <span class="math inline">\(A\)</span>. Given the distinct types of node, the connection could be represented by an <em>undirected</em> edge. (This situation gives rise to a <em>bipartite</em> graph.)</p>
</section>
<section id="relationship-examples" class="level3" data-number="14.1.2">
<h3 data-number="14.1.2" class="anchored" data-anchor-id="relationship-examples"><span class="header-section-number">14.1.2</span> Relationship examples</h3>
<p>Person <span class="math inline">\(A\)</span> knows person <span class="math inline">\(B\)</span>.</p>
<p>Person <span class="math inline">\(A\)</span> helps to create content <span class="math inline">\(B\)</span> (article, book, movie, recording, …).</p>
<p>Person <span class="math inline">\(A\)</span> attends event <span class="math inline">\(B\)</span>.</p>
<p>Locations <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are connected via public transport.</p>
<p><span class="math inline">\(A\)</span> is distance <span class="math inline">\(d\)</span> from <span class="math inline">\(B\)</span>. Then the <span class="math inline">\(A-B\)</span> edge might be given <em>weight</em> <span class="math inline">\(d\)</span>.</p>
</section>
</section>
<section id="glossary-of-basic-terms" class="level2" data-number="14.2">
<h2 data-number="14.2" class="anchored" data-anchor-id="glossary-of-basic-terms"><span class="header-section-number">14.2</span> Glossary of Basic Terms</h2>
<p>A <em>graph</em> is an ordered pair <span class="math inline">\(G = (V, E)\)</span> of a set of vertices <span class="math inline">\(V\)</span> and a set of edges <span class="math inline">\(E\)</span>. Each edge consists of a pair of vertices <span class="math inline">\((A, B)\)</span>. The edge may be denoted as <span class="math inline">\(e(A, B)\)</span> or as <span class="math inline">\(A-B\)</span>. In an undirected graph the edge <span class="math inline">\(A-B\)</span> is identical to the edge <span class="math inline">\(B-A\)</span>, whereas in an directed graph <span class="math inline">\(A-B\)</span> denotes the edge from <span class="math inline">\(A\)</span> to <span class="math inline">\(B\)</span> and is distinct from <span class="math inline">\(B-A\)</span>, the edge from <span class="math inline">\(B\)</span> to <span class="math inline">\(A\)</span>. <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<div class="cell">
<div id="tbl-graph-glossary" class="cell quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-graph-glossary-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;14.1: Graph Theory: Basic Terms
</figcaption>
<div aria-describedby="tbl-graph-glossary-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell-output-display">
<table class="do-not-create-environment cell caption-top table table-sm table-striped small">
<caption>Graph Theory: Basic Terms</caption>
<colgroup>
<col style="width: 15%">
<col style="width: 84%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">term</th>
<th style="text-align: left;">description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">acyclic</td>
<td style="text-align: left;">a graph is acyclic if it has no cycles</td>
</tr>
<tr class="even">
<td style="text-align: left;">adjacency</td>
<td style="text-align: left;">binary indicator: given vertices are / are not endpoints of a common edge</td>
</tr>
<tr class="odd">
<td style="text-align: left;">connected component</td>
<td style="text-align: left;">a maximal connected subgraph</td>
</tr>
<tr class="even">
<td style="text-align: left;">connected graph</td>
<td style="text-align: left;">a graph is connected if each pair of vertices is connected</td>
</tr>
<tr class="odd">
<td style="text-align: left;">connected vertices</td>
<td style="text-align: left;">a pair of vertices that co-occur in some path</td>
</tr>
<tr class="even">
<td style="text-align: left;">cycle</td>
<td style="text-align: left;">a finite path whose first and last vertex are the same</td>
</tr>
<tr class="odd">
<td style="text-align: left;">degree</td>
<td style="text-align: left;">number of incident edges of a vertex</td>
</tr>
<tr class="even">
<td style="text-align: left;">directed edge</td>
<td style="text-align: left;">an ordered pair of vertices (called endpoints of the edge)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">edge</td>
<td style="text-align: left;">a specified pair of vertices (in a hypergraph, more than two vertices)</td>
</tr>
<tr class="even">
<td style="text-align: left;">edge weight</td>
<td style="text-align: left;">a numerical value assigned to an edge</td>
</tr>
<tr class="odd">
<td style="text-align: left;">graph</td>
<td style="text-align: left;">a system of vertices (nodes) and edges</td>
</tr>
<tr class="even">
<td style="text-align: left;">incidence</td>
<td style="text-align: left;">if a vertex is an endpoint of an edge, the (vertex, edge) pair is said to be incident</td>
</tr>
<tr class="odd">
<td style="text-align: left;">neighborhood, 1-hop</td>
<td style="text-align: left;">the subgraph of vertices adjacent to a referenced vertex</td>
</tr>
<tr class="even">
<td style="text-align: left;">neighborhood, 1.5-hop</td>
<td style="text-align: left;">the subgraph induced by a vertex, its adjacent vertices, and their adjacent vertices</td>
</tr>
<tr class="odd">
<td style="text-align: left;">neighborhood, 2-hop</td>
<td style="text-align: left;">the subgraph of vertices of distance 2 from a referenced vertex</td>
</tr>
<tr class="even">
<td style="text-align: left;">path</td>
<td style="text-align: left;">a sequence of adjacent vertices</td>
</tr>
<tr class="odd">
<td style="text-align: left;">simple path</td>
<td style="text-align: left;">a path in which no vertex is repeated</td>
</tr>
<tr class="even">
<td style="text-align: left;">subgraph</td>
<td style="text-align: left;">a subset of edges along with their endpoints and possibly additional vertices</td>
</tr>
<tr class="odd">
<td style="text-align: left;">subgraph, induced</td>
<td style="text-align: left;">a subset of vertices along with the edges having both endpoints in the subset</td>
</tr>
<tr class="even">
<td style="text-align: left;">tree, directed</td>
<td style="text-align: left;">a directed graph having a distinguished root vertex R such that there is exactly one path from R to any other vertex V</td>
</tr>
<tr class="odd">
<td style="text-align: left;">tree, undirected</td>
<td style="text-align: left;">a connected, acyclic graph</td>
</tr>
</tbody>
</table>
</div>
</div>
</figure>
</div>
</div>
</section>
<section id="properties" class="level2" data-number="14.3">
<h2 data-number="14.3" class="anchored" data-anchor-id="properties"><span class="header-section-number">14.3</span> Properties</h2>
<section id="matrix-representations" class="level3" data-number="14.3.1">
<h3 data-number="14.3.1" class="anchored" data-anchor-id="matrix-representations"><span class="header-section-number">14.3.1</span> Matrix Representations</h3>
<p>Let <span class="math inline">\(G\)</span> be a graph having <span class="math inline">\(n_V\)</span> nodes.</p>
<section id="adjacency-matrix" class="level4" data-number="14.3.1.1">
<h4 data-number="14.3.1.1" class="anchored" data-anchor-id="adjacency-matrix"><span class="header-section-number">14.3.1.1</span> Adjacency matrix</h4>
<p>The <span class="math inline">\(n_V \times n_V\)</span> adjacency matrix identifies adjacent nodes, and is defined as follows. <a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<p><span id="eq-adjacency-matrix"><span class="math display">\[
\begin{align}
  A_{j, k} &amp;=
  \begin{cases}
    1 &amp; \text{ if } e(\nu_j, \nu_k) \in E \\
    0 &amp; \text{ otherwise}
  \end{cases}
\end{align}
\qquad(14.1)\]</span></span></p>
<p>The same information can be represented by a matrix having just two columns that lists only those vertex pairs <span class="math inline">\((\nu_1, \nu_2)\)</span> that define an edge of the graph. Such a sparse matrix representation may also be used to list only a subset of edges. The selected subset may be designed, for example, to achieve computational efficiency.</p>
</section>
<section id="degree-matrix" class="level4" data-number="14.3.1.2">
<h4 data-number="14.3.1.2" class="anchored" data-anchor-id="degree-matrix"><span class="header-section-number">14.3.1.2</span> Degree matrix</h4>
<p>In an undirected graph, the degree matrix is an <span class="math inline">\(n_V \times n_V\)</span> diagonal matrix <span class="math inline">\(D\)</span> in which diagonal element <span class="math inline">\(D_{i, i}\)</span> counts the number of edges incident with node <span class="math inline">\(\nu_i\)</span>. <span class="math inline">\(D_{i, i}\)</span> is called the degree of node <span class="math inline">\(\nu_i\)</span>, and is related to the adjacency matrix as follows. <a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
<p><span id="eq-degree-matrix"><span class="math display">\[
\begin{align}
  D_{i, i} &amp;= \sum_{k = 1}^{n_V} A_{i, k}
\end{align}
\qquad(14.2)\]</span></span></p>
<p>In a directed graph the adjacency matrix may not be symmetric. The edges incident with node <span class="math inline">\(\nu_i\)</span> of the form <span class="math inline">\(e(\nu_i, \nu_k)\)</span> are “out-edges” of <span class="math inline">\(\nu_i\)</span>, whereas those of the form <span class="math inline">\(e(\nu_j, \nu_i)\)</span> are “in-edges”. The “out-degree” <span class="math inline">\(D_{i, i}^{(out)}\)</span> and “in-degree” <span class="math inline">\(D_{i, i}^{(in)}\)</span> are respectively the sum across columns of each row, and the sum across rows of each column.</p>
<p><span id="eq-degree-matrix-in-out"><span class="math display">\[
\begin{align}
  D_{i, i}^{(out)} &amp;= \sum_{k = 1}^{n_V} A_{i, k} \\
  D_{i, i}^{(in)}  &amp;= \sum_{j = 1}^{n_V} A_{j, i}
\end{align}
\qquad(14.3)\]</span></span></p>
</section>
<section id="laplacian-matrix" class="level4" data-number="14.3.1.3">
<h4 data-number="14.3.1.3" class="anchored" data-anchor-id="laplacian-matrix"><span class="header-section-number">14.3.1.3</span> Laplacian matrix</h4>
<p>In an undirected graph, the Laplacian (or Kirchhoff) matrix is an <span class="math inline">\(n_V \times n_V\)</span> matrix <span class="math inline">\(L\)</span> defined as follows. <a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></p>
<p><span id="eq-Laplacian-matrix"><span class="math display">\[
\begin{align}
  L &amp;= D - A
\end{align}
\qquad(14.4)\]</span></span></p>
<p>Consequently</p>
<p><span id="eq-Laplacian-matrix-elements"><span class="math display">\[
\begin{align}
  L_{j, k} &amp;=
  \begin{cases}
    D_{j, j} &amp; \text{ if } j = k \\
    -1 &amp; \text{ if } j\ne k \text{ and } e(\nu_j, \nu_k) \in E \\
    0 &amp; \text{ otherwise}
  \end{cases}
\end{align}
\qquad(14.5)\]</span></span></p>
</section>
</section>
<section id="betweenness-centrality" class="level3" data-number="14.3.2">
<h3 data-number="14.3.2" class="anchored" data-anchor-id="betweenness-centrality"><span class="header-section-number">14.3.2</span> Betweenness centrality</h3>
<p>Question: Which nodes and edges are “central”? <a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a></p>
<section id="nodes" class="level4" data-number="14.3.2.1">
<h4 data-number="14.3.2.1" class="anchored" data-anchor-id="nodes"><span class="header-section-number">14.3.2.1</span> Nodes</h4>
<p>The notion of <code>betweenness centrality</code> is that a node <span class="math inline">\(v\)</span> is central to a graph if it is often included in the shortest paths between any connected nodes of the graph. This notion was formally defined in the late 1970’s as the following measure <span class="math inline">\(\gamma_V(v)\)</span> of the betweenness centrality of node <span class="math inline">\(v\)</span>.</p>
<p><span id="eq-v-b-centrality-defn"><span class="math display">\[
\begin{align}
  \gamma_V(v) &amp;= \sum_{s, t \ne v}
    \frac{\sigma_{s, t} (v)}{\sigma_{s, t}}
\end{align}
\qquad(14.6)\]</span></span></p>
<p>where</p>
<p><span id="eq-v-b-centrality-2"><span class="math display">\[
\begin{align}
  (s, t) &amp;= \text{ distinct connected nodes} \\
  \mathcal{P}_{s, t} &amp;= \text{ shortest paths from } s \text{ to } t \\
  \mathcal{P}_{s, t} (v) &amp;= \text{ shortest paths from } s \text{ to } t \text{ that pass through } v \\
  \sigma_{s, t} &amp;= \text{ number of paths in } \mathcal{P}_{s, t} \\
  \sigma_{s, t} (v) &amp;= \text{ number of paths in } \mathcal{P}_{s, t} (v)
\end{align}
\qquad(14.7)\]</span></span></p>
<p>The following conventions simplify the notation.</p>
<p><span id="eq-centrality-conventions"><span class="math display">\[
\begin{align}
  \sigma_{s, t} &amp;= 1 &amp; \text{ if } s = t \\
  \sigma_{s, t} (v) &amp;= 0 &amp; \text{ if } v \in \{ s, t \}
\end{align}
\qquad(14.8)\]</span></span></p>
<p>Note that each term in the sum within <a href="#eq-v-b-centrality-defn" class="quarto-xref">Equation&nbsp;<span>14.6</span></a> is a fraction known as the <em>pair dependency</em> of <span class="math inline">\((s, t)\)</span> on <span class="math inline">\(v\)</span>, denoted as follows.</p>
<p><span id="eq-pair-dependency-defn"><span class="math display">\[
\begin{align}
  \delta_{s, t}(v) &amp;= \frac{\sigma_{s, t} (v)}{\sigma_{s, t}}
\end{align}
\qquad(14.9)\]</span></span></p>
<p>This is the proportion of shortest paths from node <span class="math inline">\(s\)</span> to node <span class="math inline">\(t\)</span> that include node <span class="math inline">\(v\)</span>. The proportion thus falls within the closed unit interval: <span class="math inline">\(0 \le \delta_{s, t}(v) \le 1\)</span>.</p>
<p>A related quantity is the <em>single dependency</em> of <span class="math inline">\(s\)</span> on <span class="math inline">\(v\)</span>, defined as follows.</p>
<p><span id="eq-single-dependency-defn"><span class="math display">\[
\begin{align}
  \delta_s(v) &amp;= \sum_{t \not \in \{s, v \}} \delta_{s, t}(v)
\end{align}
\qquad(14.10)\]</span></span></p>
<p>In words, for a fixed starting point <span class="math inline">\(s\)</span> and a fixed intermediate node <span class="math inline">\(v\)</span> this is the sum over end-points <span class="math inline">\(t\)</span> of the paired dependency of <span class="math inline">\((s, t)\)</span> on <span class="math inline">\(v\)</span>. Then we have</p>
<p><span id="eq-v-b-centrality-3"><span class="math display">\[
\begin{align}
  \gamma_V(v) &amp;= \sum_{s \ne v} \delta_s(v)
\end{align}
\qquad(14.11)\]</span></span></p>
</section>
<section id="edges" class="level4" data-number="14.3.2.2">
<h4 data-number="14.3.2.2" class="anchored" data-anchor-id="edges"><span class="header-section-number">14.3.2.2</span> Edges</h4>
<p>The betweenness centrality of an edge is defined similarly to that for a node.</p>
<p><span id="eq-e-b-centrality-defn"><span class="math display">\[
\begin{align}
  \gamma_E(e) &amp;= \sum_{s, t \in V}
    \frac{\sigma_{s, t} (e)}{\sigma_{s, t}}
\end{align}
\qquad(14.12)\]</span></span></p>
<p>Summation is over all pairs <span class="math inline">\((s, t)\)</span> of connected nodes. Each term of the summation is a fraction, namely the proportion of shortest paths from <span class="math inline">\(s\)</span> to <span class="math inline">\(t\)</span> that include edge <span class="math inline">\(e\)</span>.</p>
</section>
</section>
<section id="connected-components" class="level3" data-number="14.3.3">
<h3 data-number="14.3.3" class="anchored" data-anchor-id="connected-components"><span class="header-section-number">14.3.3</span> Connected components</h3>
<p>In graph theory, a component of an undirected graph is a connected subgraph that is not part of any larger connected subgraph. The components of any graph partition its vertices into disjoint sets, and are the induced subgraphs of those sets. A graph that is itself connected has exactly one component, namely the entire graph. Components are sometimes called connected components. In <code>R</code> graph components can be determined by function <code>igraph::components()</code>. <a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a></p>
</section>
<section id="communities" class="level3" data-number="14.3.4">
<h3 data-number="14.3.4" class="anchored" data-anchor-id="communities"><span class="header-section-number">14.3.4</span> Communities</h3>
<p>In graph theory, the notion of “community” (or cluster, or module) is similar to but less stringent than that of a connected component. A community is a subgraph, with many edges joining vertices of the same community and comparatively few edges joining vertices of different communities. <a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a></p>
</section>
<section id="modularity" class="level3" data-number="14.3.5">
<h3 data-number="14.3.5" class="anchored" data-anchor-id="modularity"><span class="header-section-number">14.3.5</span> Modularity</h3>
<p>The strength of a given community structure of a graph can be measured as the <em>modularity</em> of the graph, which compares the actual number of edges between node pairs to the expected number in a randomly generated graph (constrained to preserve the degree of each node).</p>
<p>Suppose that <span class="math inline">\(c(\nu_j)\)</span> is the assignment by classification function of <span class="math inline">\(c(\cdot)\)</span> of each node <span class="math inline">\(\nu_j\)</span> to one of the integers <span class="math inline">\(\{ 1, \ldots, n_c \}\)</span>. Let <span class="math inline">\(Q(c(\cdot))\)</span> denote the modularity measure of <span class="math inline">\(c(\cdot)\)</span>. Then <span class="math inline">\(Q(\cdot)\)</span> is defined compatably but distinctly for directed versus undirected graphs.</p>
<section id="undirected-graphs" class="level4" data-number="14.3.5.1">
<h4 data-number="14.3.5.1" class="anchored" data-anchor-id="undirected-graphs"><span class="header-section-number">14.3.5.1</span> Undirected graphs</h4>
<p>For an undirected graph, modularity <span class="math inline">\(Q(\cdot)\)</span> is defined as follows.</p>
<p><span id="eq-modularity-defn"><span class="math display">\[
\begin{align}
  Q &amp;= \frac{1}{2 n_E} \sum_{j, k = 1}^{n_V} \left (A_{j, k} - \frac{D_{j, j} \; D_{k, k}}{2 n_E} \right ) \; \delta(c(\nu_j), c(\nu_k))
\end{align}
\qquad(14.13)\]</span></span></p>
<p>where</p>
<p><span id="eq-modularity-defn-2"><span class="math display">\[
\begin{align}
  n_E &amp;= \left| E \right| \text{ = number of edges} \\
  n_V &amp;= \left| V \right| \text{ = number of nodes} \\
  A &amp;= \text{adjacency matrix} \\
  D_{i, i} &amp;= \text{degree of node } \nu_i \\
  \delta(\cdot) &amp;= \text{Kronecker delta function}
\end{align}
\qquad(14.14)\]</span></span></p>
</section>
<section id="directed-graphs" class="level4" data-number="14.3.5.2">
<h4 data-number="14.3.5.2" class="anchored" data-anchor-id="directed-graphs"><span class="header-section-number">14.3.5.2</span> Directed graphs</h4>
<p>For a directed graph, modularity <span class="math inline">\(Q(\cdot)\)</span> is defined thus.</p>
<p><span id="eq-modularity-defn-in-out"><span class="math display">\[
\begin{align}
  Q &amp;= \frac{1}{n_E} \sum_{j, k = 1}^{n_V} \left (A_{j, k} - \frac{D_{j, j}^{(out)}D_{k, k}^{(in)}}{n_E} \right ) \; \delta(c(\nu_j), c(\nu_k))
\end{align}
\qquad(14.15)\]</span></span></p>
</section>
<section id="agglomerative-versus-divisive-algorithms" class="level4" data-number="14.3.5.3">
<h4 data-number="14.3.5.3" class="anchored" data-anchor-id="agglomerative-versus-divisive-algorithms"><span class="header-section-number">14.3.5.3</span> Agglomerative versus divisive algorithms</h4>
<p>Consider an algorithm designed to determine community structure based on modularity. A divisive algorithm might initially assign all nodes to a single community by setting <span class="math inline">\(n_c = 1\)</span>. An agglomerative algorithm might initially assign each node to its own community by setting <span class="math inline">\(n_c = n_V\)</span>.</p>
<p>See <span class="citation" data-cites="wiki_graph_modularity"><span>“Modularity (Networks) | Wikipedia”</span> (<a href="references.html#ref-wiki_graph_modularity" role="doc-biblioref">2025</a>)</span> for further details. The modularity of a graph can be calculated in <code>R</code> by function <code>igraph:modularity()</code>.</p>
</section>
</section>
</section>
<section id="algorithms-general" class="level2" data-number="14.4">
<h2 data-number="14.4" class="anchored" data-anchor-id="algorithms-general"><span class="header-section-number">14.4</span> Algorithms: General</h2>
<section id="page-rank" class="level3" data-number="14.4.1">
<h3 data-number="14.4.1" class="anchored" data-anchor-id="page-rank"><span class="header-section-number">14.4.1</span> Page Rank</h3>
<p>Question: In a directed graph, which nodes have the most in-links?</p>
<p><code>PageRank</code> was the first algorithm used by Google to find relevant web pages in response to user queries. The algorithm determines the number and quality of links to a page under the assumption that more important websites are likely to receive more links from other websites. <a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a></p>
<p>This idea can be applied to any directed graph. Here’s an outline of a similar algorithm that assigns a score <span class="math inline">\(s(\nu)\)</span> to each node <span class="math inline">\(\nu\)</span> of directed graph <span class="math inline">\(G = (V, E)\)</span> having <span class="math inline">\(n_V\)</span> nodes. For each node <span class="math inline">\(\nu\)</span> the score is initially set to <span class="math inline">\(s(\nu) = \frac{1}{n_V}\)</span>. Then the algorithm iterates over the following steps: <a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a></p>
<ol type="1">
<li><em>Distribute</em> <span class="math inline">\(s(\nu)\)</span> equally among the out-neighbors of <span class="math inline">\(\nu\)</span>.</li>
<li><em>Update</em> <span class="math inline">\(s(\nu)\)</span> to be the sum of all scores received from the in-neighbors of <span class="math inline">\(\nu\)</span>.</li>
<li><em>Shrink</em> toward uniformity: set <span class="math inline">\(s(\nu) \leftarrow (1 - \epsilon) s(\nu) + \epsilon \frac{1}{n_V}\)</span>, for some <span class="math inline">\(\epsilon \approx 0.15\)</span>.</li>
</ol>
<p>The algorithm can also be expressed using the <span class="math inline">\(n_V \times n_V\)</span> matrix <span class="math inline">\(T\)</span> to represent the distribution of each node’s score to the scores of its out-neighbors, so that</p>
<p><span id="eq-transition-matrix"><span class="math display">\[
\begin{align}
  T_{j, k}  &amp;=
  \begin{cases}
    \frac{1}{d_j} &amp; \text{if } \nu_j \text{ has a directed link to } \nu_k \\
    0 &amp; \text{ otherwise}
  \end{cases} \\ \\
  &amp;\text{where} \\ \\
  d_j &amp;= \text{number of out-neighbors of } \nu_j
\end{align}
\qquad(14.16)\]</span></span></p>
<p>Let <span class="math inline">\(s^{(i)}_\bullet = (s^{(i)}_1, \ldots, s^{(i)}_{n_V})\)</span> denote the vector of node-scores at the <span class="math inline">\(i^{th}\)</span> iteration. Also let <span class="math inline">\(1_\bullet = (1, \ldots, 1)\)</span> denote the vector of length <span class="math inline">\(n_V\)</span> each of whose elements is equal to unity, so that <span class="math inline">\(1_\bullet \otimes 1_\bullet\)</span> denotes the <span class="math inline">\(n_V \times n_V\)</span> matrix each of whose elements is equal to unity. Then the algorithm can be represented as the following linear system, iterated over index <span class="math inline">\(i\)</span>.</p>
<p><span id="eq-node-score-iteration"><span class="math display">\[
\begin{align}
  s^{(0)}_\bullet &amp;= \frac{1}{n_V} 1_\bullet \\
  s^{(i)}_\bullet &amp;= s^{(i-1)}_\bullet \; \times \; M \\
  M &amp;= (1 - \epsilon) \; T \; + \; \frac{\epsilon}{n_V} \; 1_\bullet \otimes 1_\bullet
\end{align}
\qquad(14.17)\]</span></span></p>
<p>The matrix <span class="math inline">\(T\)</span> is a Markov transition matrix: that is, the elements of each row are non-negative and sum to unity. Then there is at least one probability vector <span class="math inline">\(\pi_\bullet\)</span> for which <span class="math inline">\(\pi_\bullet \times T = \pi_\bullet\)</span>. Vector <span class="math inline">\(\pi_\bullet\)</span> is thus a left eigenvector of <span class="math inline">\(T\)</span> corresponding to an eigenvalue of 1, and is a stationary probability vector corresponding to <span class="math inline">\(T\)</span>. <a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a></p>
<p>Matrix <span class="math inline">\(M\)</span> is also a Markov transition matrix with its own stationary distribution, say <span class="math inline">\(\bar{s}_\bullet\)</span>. Moreover, <span class="math inline">\(M\)</span> is irreducible, meaning that <span class="math inline">\(M\)</span> assigns positive probability of reaching any node from any other node. Consequently <span class="math inline">\(\bar{s}_\bullet\)</span> is the <em>unique</em> stationary distribution of <span class="math inline">\(M\)</span>. It also follows that iterating the above linear system gives a sequence of score vectors <span class="math inline">\(s^{(i)}_\bullet\)</span> that converge to <span class="math inline">\(\bar{s}_\bullet\)</span>.</p>
<p><span id="eq-converge-to-stationary-dstn"><span class="math display">\[
\begin{align}
  \lim_{i \rightarrow \infty}{s^{(i)}_\bullet} &amp;= \bar{s}_\bullet
\end{align}
\qquad(14.18)\]</span></span></p>
<p>In 1999 Google noted that acceptable convergence of the <code>PageRank</code> algorithm typically required about 50 iterations for internet-sized graphs. <a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a></p>
<p>The algorithm is implemented in <code>R</code> as the function <code>igraph::page_rank()</code>.</p>
</section>
<section id="floyd-warshall" class="level3" data-number="14.4.2">
<h3 data-number="14.4.2" class="anchored" data-anchor-id="floyd-warshall"><span class="header-section-number">14.4.2</span> Floyd-Warshall</h3>
<p>Question: In a directed weighted graph, what is the distance from one node to another: how long is the shortest path?</p>
<p>Suppose we are given a directed weighted graph <span class="math inline">\(G\)</span> having <span class="math inline">\(n_V\)</span> nodes indexed as <span class="math inline">\(\{ \nu_1, \nu_2, \ldots, \nu_{n_V} \}\)</span>. For any path from node <span class="math inline">\(\nu_j\)</span> to node <span class="math inline">\(\nu_k\)</span>, the length of the path is the sum of the weights of the edges making up the path.</p>
<p>Consider the shortest of those paths from <span class="math inline">\(\nu_j\)</span> to <span class="math inline">\(\nu_k\)</span> that are restricted to intermediary nodes <span class="math inline">\(N_m = \{ \nu_1, \nu_2, \ldots, \nu_m \}\)</span>, that is, constrained to exclude intermediary nodes other than those in <span class="math inline">\(N_m\)</span>. If there is such a shortest path that moreover excludes node <span class="math inline">\(\nu_m\)</span>, then it is also the shortest path restricted to intermediary nodes <span class="math inline">\(N_{m - 1} = \{ \nu_1, \nu_2, \ldots, \nu_{m - 1} \}\)</span>.</p>
<p>Otherwise, if any shortest path includes node <span class="math inline">\(\nu_m\)</span>, that path is the concatenation of: (1) a shortest path from <span class="math inline">\(\nu_j\)</span> to <span class="math inline">\(\nu_m\)</span> restricted to nodes <span class="math inline">\(N_{m - 1}\)</span>; and (2) a shortest path from <span class="math inline">\(\nu_m\)</span> to <span class="math inline">\(\nu_k\)</span> restricted to nodes <span class="math inline">\(N_{m - 1}\)</span>.</p>
<p>If node <span class="math inline">\(\nu_j\)</span> happens to be connected to <span class="math inline">\(\nu_k\)</span> by the edge <span class="math inline">\(\nu_j - \nu_k\)</span>, then that edge qualifies as the shortest path restricted to the empty set of intermediary nodes.</p>
<p>We now use these observations about intermediary nodes to construct an algorithm to determine the minimal distance from any node to any node. We will record these distances in the <span class="math inline">\(n_v \times n_V\)</span> matrix <span class="math inline">\(D\)</span>. <a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a></p>
<p><span id="eq-distance-matrix-defn"><span class="math display">\[
\begin{align}
  D_{j, k} &amp;= \text{distance from } \nu_j \text{ to } \nu_k
\end{align}
\qquad(14.19)\]</span></span></p>
<p>We set initial values to matrix <span class="math inline">\(D\)</span> as follows.</p>
<p><span id="eq-distance-matrix-initial-values"><span class="math display">\[
\begin{align}
  D^{(0)}_{j, k} &amp;=
  \begin{cases}
    \text{weight of edge } \nu_j - \nu_k &amp; \text{if that edge exists} \\
    \infty &amp; \text{otherwise}
  \end{cases}
\end{align}
\qquad(14.20)\]</span></span></p>
<p>We now update these matrix values as follows.</p>
<p><span id="eq-distance-matrix-updates"><span class="math display">\[
\begin{align}
  D^{(i + 1)}_{j, k} &amp;= \min \left \{ D^{(i)}_{j, k} \;,\; \{ D^{(i)}_{j, m} + D^{(i)}_{m, k} \}_{m \not \in \{ j, k \}} \right \}
\end{align}
\qquad(14.21)\]</span></span></p>
<p>The algorithm is implemented in <code>R</code> as the function <code>Rfast::floyd()</code>.</p>
</section>
<section id="dijkstra" class="level3" data-number="14.4.3">
<h3 data-number="14.4.3" class="anchored" data-anchor-id="dijkstra"><span class="header-section-number">14.4.3</span> Dijkstra</h3>
<p>Question: In a weighted graph, how long is the shortest path between two given nodes, or between a given node and every other node?</p>
<p><span class="math inline">\(G\)</span> is now an undirected, weighted graph, again having <span class="math inline">\(n_V\)</span> nodes. A starting node <span class="math inline">\(\nu_1\)</span> is identified, but the remaining nodes will be later indexed as <span class="math inline">\(\{ \nu_2, \ldots, \nu_{n_V} \}\)</span> as part of the algorithm. The <span class="math inline">\(n_v \times n_V\)</span> distance matrix <span class="math inline">\(D\)</span> is now symmetric. Our goal is to determine the values of the first row of <span class="math inline">\(D\)</span> (or possibly an identified target cell in the first row).</p>
<p>Dijkstra’s algorithm starts with infinite distances and tries to improve them step by step: <a href="#fn14" class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a></p>
<ol type="1">
<li>Create a set <span class="math inline">\(\mathcal{U}\)</span> of unvisited nodes, with <span class="math inline">\(\mathcal{U}\)</span> initialized as <span class="math inline">\(V\)</span>, the set of all nodes.</li>
<li>Assign an initial distance <span class="math inline">\(D^{(0)}_{1, j}\)</span> from <span class="math inline">\(\nu_1\)</span> to every node <span class="math inline">\(\nu_j\)</span>, with <span class="math inline">\(D^{(0)}_{1, 1} = 0\)</span> and <span class="math inline">\(D^{(0)}_{1, j} = \infty\)</span> for <span class="math inline">\(j \ne 1\)</span>.</li>
<li>From the unvisited set, select the current node, <span class="math inline">\(\nu_i\)</span>, to be the one with the smallest (finite) distance; initially (for <span class="math inline">\(i = 1\)</span>), this is the starting node <span class="math inline">\(\nu_1\)</span> (having distance zero). If the unvisited set is empty, or contains only nodes with infinite distance (which are unreachable), then the algorithm terminates by skipping to step 6. If the only concern is the path to a target node, the algorithm terminates once the current node is the target node. Otherwise, the algorithm continues.</li>
<li>Now examine nodes adjacent to <span class="math inline">\(\nu_i\)</span> that are still elements of <span class="math inline">\(\mathcal{U}\)</span>. Calculate the distance of each adjacent node from <span class="math inline">\(\nu_1\)</span> through the current node <span class="math inline">\(\nu_i\)</span>. Update the distance from <span class="math inline">\(\nu_1\)</span> to the adjacent node to be the minimum of the previously recorded distance and the new calculation.</li>
<li>After considering all of the current node’s unvisited neighbors, the current node is removed from the unvisited set. Thus a visited node is never rechecked, which is correct because the distance recorded on the current node is minimal (as ensured in step 3), and thus final. Repeat from step 3.</li>
<li>Once the loop exits (steps 3–5), every visited node contains its shortest distance from the starting node.</li>
</ol>
<p>The algorithm is implemented in <code>R</code> as the function <code>igraph::distances()</code>.</p>
</section>
<section id="brandes" class="level3" data-number="14.4.4">
<h3 data-number="14.4.4" class="anchored" data-anchor-id="brandes"><span class="header-section-number">14.4.4</span> Brandes</h3>
<p>Brandes’ algorithm calculates the betweenness centrality of all nodes in a graph, with the aid of the following definitions. <a href="#fn15" class="footnote-ref" id="fnref15" role="doc-noteref"><sup>15</sup></a></p>
<p>Let <span class="math inline">\(\mathcal{l}(s, v)\)</span> denote the length of a shortest path from node <span class="math inline">\(s\)</span> to node <span class="math inline">\(v\)</span>. Note: Brandes’ algorithm assumes that all edge-weights are equal to unity (or share some other positive constant value).</p>
<p>Also let <span class="math inline">\(\mathcal{C}_s(v)\)</span> denote the neighbors of <span class="math inline">\(v\)</span> that are closer to <span class="math inline">\(s\)</span> than is <span class="math inline">\(v\)</span>.</p>
<p><span id="eq-closer-than-v"><span class="math display">\[
\begin{align}
  \mathcal{C}_s(v) &amp;= \left \{ u \in V :
    (u-v) \in E \; \wedge \; \mathcal{l}(s, u) &lt; \mathcal{l}(s, v) \right \}
\end{align}
\qquad(14.22)\]</span></span></p>
<p>The idea here is that for any given node <span class="math inline">\(s\)</span>, the remaining nodes can be partitioned based on their distance from <span class="math inline">\(s\)</span>. The partition is simplified by the assumption that all edges have the same weight (unity or some other positive constant). Node <span class="math inline">\(v\)</span> belongs to the set of nodes that are the same distance from <span class="math inline">\(s\)</span> as is <span class="math inline">\(v\)</span>. If node <span class="math inline">\(u\)</span> is adjacent to <span class="math inline">\(v\)</span> and is closer to <span class="math inline">\(s\)</span> than is <span class="math inline">\(v\)</span>, then it must be just one unit closer and thus belong to that corresponding set of nodes.</p>
<p>For each vertex <span class="math inline">\(s\)</span> the algorithm iterates over two stages: (1) shortest path determination ; and (2) back-propagation. The algorithm is implemented in <code>R</code> as the function <code>igraph::betweenness()</code>.</p>
<section id="single-source-shortest-path" class="level4" data-number="14.4.4.1">
<h4 data-number="14.4.4.1" class="anchored" data-anchor-id="single-source-shortest-path"><span class="header-section-number">14.4.4.1</span> Single-source shortest path</h4>
<p><a href="#eq-closer-than-v" class="quarto-xref">Equation&nbsp;<span>14.22</span></a> yields the following iterative formula for <span class="math inline">\(\sigma_{s, v}\)</span>. <a href="#fn16" class="footnote-ref" id="fnref16" role="doc-noteref"><sup>16</sup></a></p>
<p><span id="eq-sigma-recursion"><span class="math display">\[
\begin{align}
  \sigma_{s, v} &amp;= \sum_{u \in \mathcal{C}_s(v)} \sigma_{s, u}
\end{align}
\qquad(14.23)\]</span></span></p>
<p>That is, if node <span class="math inline">\(v\)</span> is not adjacent to node <span class="math inline">\(s\)</span> then any shortest path from <span class="math inline">\(s\)</span> to <span class="math inline">\(v\)</span> must have a member of <span class="math inline">\(\mathcal{C}_s(v)\)</span> as its penultimate node, and these penultimate nodes partition the shortest paths from <span class="math inline">\(s\)</span> to <span class="math inline">\(v\)</span>. On the other hand, if <span class="math inline">\((s-v)\)</span> is an edge then that edge is the unique shortest path from <span class="math inline">\(s\)</span> to <span class="math inline">\(v\)</span>, in which case <span class="math inline">\(\sigma_{s, v} = 1\)</span>.</p>
</section>
<section id="backpropagation" class="level4" data-number="14.4.4.2">
<h4 data-number="14.4.4.2" class="anchored" data-anchor-id="backpropagation"><span class="header-section-number">14.4.4.2</span> Backpropagation</h4>
<p>Brandes proved the following recursive formula for vertex dependencies:</p>
<p><span id="eq-delta-recursion"><span class="math display">\[
\begin{align}
  \delta_{s} (u) &amp;= \sum_{v : u \in \mathcal{C}_s(v)}
    \frac{\sigma_{s, u}}{\sigma_{s, v}} \times (\delta_s(v) + 1)
\end{align}
\qquad(14.24)\]</span></span></p>
<p>According to this formula the single dependency of <span class="math inline">\(s\)</span> on a vertex <span class="math inline">\(u\)</span> at distance <span class="math inline">\(\mathcal{l}(s, u)\)</span> is determined by the the set of nodes at the next greater distance. Furthermore, the order of summation is irrelevant, which enables calculations to start at the most distant set of nodes.</p>
</section>
</section>
</section>
<section id="algorithms-clustering" class="level2" data-number="14.5">
<h2 data-number="14.5" class="anchored" data-anchor-id="algorithms-clustering"><span class="header-section-number">14.5</span> Algorithms: Clustering</h2>
<section id="girvan-newman" class="level3" data-number="14.5.1">
<h3 data-number="14.5.1" class="anchored" data-anchor-id="girvan-newman"><span class="header-section-number">14.5.1</span> Girvan-Newman</h3>
<p>Question: How can one identify highly connected communities of nodes? <a href="#fn17" class="footnote-ref" id="fnref17" role="doc-noteref"><sup>17</sup></a></p>
<p>If a graph contains groups (communities) of nodes that are only loosely connected by a few inter-group edges, then all shortest paths between different communities must go along one of these few edges. Thus the edges connecting communities will have high edge betweenness. By removing these edges, the communities are separated from one another and so the underlying community structure of the graph is revealed.</p>
<p>Girvan–Newman is a hierarchical, divisive algorithm that detects communities by iteratively removing a most central edge, and then recomputing the betweenness centrality of edges belonging to the component containing the removed edge. The connected components of the resulting graph are the communities.</p>
<p>The algorithm is as follows.</p>
<ol type="1">
<li>Calculate the betweenness for all edges.</li>
<li>Remove the edge with the highest betweenness.</li>
<li>Recalculate betweennesses for all edges affected by the removal.</li>
<li>Repeat from step 2 until no edges remain.</li>
</ol>
<p>The algorithm is implemented in <code>R</code> as the function <code>igraph::cluster_edge_betweenness()</code>.</p>
</section>
<section id="spectral-clustering" class="level3" data-number="14.5.2">
<h3 data-number="14.5.2" class="anchored" data-anchor-id="spectral-clustering"><span class="header-section-number">14.5.2</span> Spectral clustering</h3>
<p>Spectral clustering is another hierarchical, divisive method for community detection in an undirected graph. It is based on a spectral decomposition of the normalized Laplacian matrix. An outline of the iterative algorithm is as follows.</p>
<ol type="1">
<li>Compute the adjacent <span class="math inline">\((A)\)</span>, degree <span class="math inline">\((D)\)</span>, and normalized Laplacian <span class="math inline">\((\tilde{L})\)</span> matrices, with</li>
</ol>
<p><span id="eq-Laplacian-matrix-normalized"><span class="math display">\[
\begin{align}
  \tilde{L} &amp;= I - D^{-1/2} \; A \; D^{-1/2}
\end{align}
\qquad(14.25)\]</span></span></p>
<p>noting that</p>
<p><span id="eq-Laplacian-matrix-evec-0"><span class="math display">\[
\begin{align}
  \tilde{L} \times (D^{1/2} \times 1_{\bullet}) &amp;= 0
\end{align}
\qquad(14.26)\]</span></span></p>
<ol start="2" type="1">
<li><p>Compute the eigenvector <span class="math inline">\(x\)</span> corresponding to the second smallest eigenvalue of <span class="math inline">\((\tilde{L})\)</span>.</p></li>
<li><p>For each node <span class="math inline">\(\nu_j\)</span> calculate the inner product <span class="math inline">\(&lt;A_{j, \bullet}, x&gt;\)</span> (the <span class="math inline">\(x-\)</span>coordinate of <span class="math inline">\(\nu_j\)</span>).</p></li>
<li><p>Cluster nodes based on the sign (negative, or non-negative) of their <span class="math inline">\(x-\)</span>coordinate.</p></li>
</ol>
<p>See <span class="citation" data-cites="wiki_spectral_clustering"><span>“Spectral Clustering | Wikipedia”</span> (<a href="references.html#ref-wiki_spectral_clustering" role="doc-biblioref">2025</a>)</span> for further details. The algorithm can be implemented in <code>R</code> as the function <code>rSpectral::spectral_igraph_membership()</code>.</p>
</section>
<section id="clauset-newman-moore" class="level3" data-number="14.5.3">
<h3 data-number="14.5.3" class="anchored" data-anchor-id="clauset-newman-moore"><span class="header-section-number">14.5.3</span> Clauset-Newman-Moore</h3>
<p>The Clauset-Newman-Moore (CNM) algorithm is a hierarchical agglomeration algorithm to find community structure in a graph. It does so by local (“greedy”) optimization. It greedily merges clusters to increase modularity, and halts when the increase falls under some threshold. It may be forced to track the hierarchy of clusters formed, and halt only when it has created a single cluster of the entire graph. See <span class="citation" data-cites="Clauset_Newman_Moore_2004">Clauset, Newman, and Moore (<a href="references.html#ref-Clauset_Newman_Moore_2004" role="doc-biblioref">2004</a>)</span> for details. The algorithm is implemented in <code>R</code> as the function <code>igraph::cluster_fast_greedy()</code>.</p>
</section>
<section id="louvain" class="level3" data-number="14.5.4">
<h3 data-number="14.5.4" class="anchored" data-anchor-id="louvain"><span class="header-section-number">14.5.4</span> Louvain</h3>
<p>The Louvain method, like the Clauset-Newman-Moore (CNM) algorithm, uses local optimization of subgraph modularity to find community structure in a graph. Here’s an outline of the algorithm.</p>
<ol type="1">
<li>Perform CNM until modularity is maximized.</li>
<li>Contract each cluster to a single new node.</li>
<li>Set the edge-weight between new nodes to the sum of all old edge-weights between the old clusters.</li>
<li>Return to step 1 with the contracted graph.</li>
</ol>
<p>See <span class="citation" data-cites="wiki_louvain_method"><span>“Louvain Method | Wikipedia”</span> (<a href="references.html#ref-wiki_louvain_method" role="doc-biblioref">2025</a>)</span> for further details.</p>
<p>Louvain produces non-overlapping communities: each node belongs to at most one community. This may be unrealistic in real-world applications. As an alternative, the Leiden algorithm can produce overlapping communities.</p>
<p>The Louvain method is implemented in <code>R</code> as the function <code>igraph::cluster_louvain()</code>.</p>
</section>
<section id="leiden" class="level3" data-number="14.5.5">
<h3 data-number="14.5.5" class="anchored" data-anchor-id="leiden"><span class="header-section-number">14.5.5</span> Leiden</h3>
<p>The Leiden method, developed in 2019 as a modification of the Louvain method, allows the identification of overlapping communities. See <span class="citation" data-cites="wiki_leiden_algo"><span>“Leiden Algorithm | Wikipedia”</span> (<a href="references.html#ref-wiki_leiden_algo" role="doc-biblioref">2025</a>)</span> for details. The algorithm is implemented in <code>R</code> as the function <code>igraph::cluster_leiden()</code>.</p>


<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-wiki_adjacency_matrix" class="csl-entry" role="listitem">
<span>“Adjacency Matrix | Wikipedia.”</span> 2025. <em>Wikipedia</em>, October. <a href="https://en.wikipedia.org/wiki/Adjacency_matrix">https://en.wikipedia.org/wiki/Adjacency_matrix</a>.
</div>
<div id="ref-wiki_betweenness_centrality" class="csl-entry" role="listitem">
<span>“Betweenness Centrality | Wikipedia.”</span> 2025. <em>Wikipedia</em>, October. <a href="https://en.wikipedia.org/wiki/Betweenness_centrality">https://en.wikipedia.org/wiki/Betweenness_centrality</a>.
</div>
<div id="ref-wiki_Brandes_algo" class="csl-entry" role="listitem">
<span>“Brandes’ Algorithm | Wikipedia.”</span> 2025. <em>Wikipedia</em>, October. <a href="https://en.wikipedia.org/wiki/Brandes%27_algorithm">https://en.wikipedia.org/wiki/Brandes%27_algorithm</a>.
</div>
<div id="ref-Clauset_Newman_Moore_2004" class="csl-entry" role="listitem">
Clauset, Aaron, M. E. J. Newman, and Cristopher Moore. 2004. <span>“Finding Community Structure in Very Large Networks.”</span> <em>Physical Review E</em>. https://doi.org/<a href="https://doi.org/10.1103/PhysRevE.70.066111">https://doi.org/10.1103/PhysRevE.70.066111</a>.
</div>
<div id="ref-wiki_connected_component" class="csl-entry" role="listitem">
<span>“Component (Graph Theory) | Wikipedia.”</span> 2025. <em>Wikipedia</em>, October. <a href="https://en.wikipedia.org/wiki/Component_(graph_theory)">https://en.wikipedia.org/wiki/Component_(graph_theory)</a>.
</div>
<div id="ref-wiki_degree_matrix" class="csl-entry" role="listitem">
<span>“Degree Matrix | Wikipedia.”</span> 2025. <em>Wikipedia</em>, October. <a href="https://en.wikipedia.org/wiki/Degree_matrix">https://en.wikipedia.org/wiki/Degree_matrix</a>.
</div>
<div id="ref-wiki_Dijkstra_algo" class="csl-entry" role="listitem">
<span>“Dijkstra’s Algorithm | Wikipedia.”</span> 2025. <em>Wikipedia</em>, October. <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm</a>.
</div>
<div id="ref-wiki_Floyd_Warshall_algo" class="csl-entry" role="listitem">
<span>“Floyd–Warshall Algorithm | Wikipedia.”</span> 2025. <em>Wikipedia</em>, October. <a href="https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm">https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm</a>.
</div>
<div id="ref-Fortunato_2010" class="csl-entry" role="listitem">
Fortunato, Santo. 2010. <span>“Community Detection in Graphs.”</span> <em>Physics Reports</em>, February. <a href="https://doi.org/10.1016/j.physrep.2009.11.002">https://doi.org/10.1016/j.physrep.2009.11.002</a>.
</div>
<div id="ref-wiki_Girvan_Newman_algo" class="csl-entry" role="listitem">
<span>“Girvan–Newman Algorithm | Wikipedia.”</span> 2025. <em>Wikipedia</em>, October. <a href="https://en.wikipedia.org/wiki/Girvan%E2%80%93Newman_algorithm">https://en.wikipedia.org/wiki/Girvan%E2%80%93Newman_algorithm</a>.
</div>
<div id="ref-wiki_graph_glossary" class="csl-entry" role="listitem">
<span>“Glossary of Graph Theory | Wikipedia.”</span> 2025. <em>Wikipedia</em>, October. <a href="https://en.wikipedia.org/wiki/Glossary_of_graph_theory">https://en.wikipedia.org/wiki/Glossary_of_graph_theory</a>.
</div>
<div id="ref-wiki_graph_theory" class="csl-entry" role="listitem">
<span>“Graph Theory | Wikipedia.”</span> 2025. <em>Wikipedia</em>, October. <a href="https://en.wikipedia.org/wiki/Graph_theory">https://en.wikipedia.org/wiki/Graph_theory</a>.
</div>
<div id="ref-wiki_Laplacian_matrix" class="csl-entry" role="listitem">
<span>“Laplacian Matrix | Wikipedia.”</span> 2025. <em>Wikipedia</em>, October. <a href="https://en.wikipedia.org/wiki/Laplacian_matrix">https://en.wikipedia.org/wiki/Laplacian_matrix</a>.
</div>
<div id="ref-wiki_leiden_algo" class="csl-entry" role="listitem">
<span>“Leiden Algorithm | Wikipedia.”</span> 2025. <em>Wikipedia</em>, October. <a href="https://en.wikipedia.org/wiki/Leiden_algorithm">https://en.wikipedia.org/wiki/Leiden_algorithm</a>.
</div>
<div id="ref-wiki_louvain_method" class="csl-entry" role="listitem">
<span>“Louvain Method | Wikipedia.”</span> 2025. <em>Wikipedia</em>, October. <a href="https://en.wikipedia.org/wiki/Louvain_method">https://en.wikipedia.org/wiki/Louvain_method</a>.
</div>
<div id="ref-wiki_Markov_chain" class="csl-entry" role="listitem">
<span>“Markov Chain | Wikipedia.”</span> 2025. <em>Wikipedia</em>, October. <a href="https://en.wikipedia.org/wiki/Markov_chain">https://en.wikipedia.org/wiki/Markov_chain</a>.
</div>
<div id="ref-wiki_graph_modularity" class="csl-entry" role="listitem">
<span>“Modularity (Networks) | Wikipedia.”</span> 2025. <em>Wikipedia</em>, October. <a href="https://en.wikipedia.org/wiki/Modularity_(networks)">https://en.wikipedia.org/wiki/Modularity_(networks)</a>.
</div>
<div id="ref-wiki_PageRank" class="csl-entry" role="listitem">
<span>“PageRank | Wikipedia.”</span> 2025. <em>Wikipedia</em>, October. <a href="https://en.wikipedia.org/wiki/PageRank">https://en.wikipedia.org/wiki/PageRank</a>.
</div>
<div id="ref-wiki_spectral_clustering" class="csl-entry" role="listitem">
<span>“Spectral Clustering | Wikipedia.”</span> 2025. <em>Wikipedia</em>, October. <a href="https://en.wikipedia.org/wiki/Spectral_clustering">https://en.wikipedia.org/wiki/Spectral_clustering</a>.
</div>
</div>
</section>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>See <span class="citation" data-cites="wiki_graph_theory"><span>“Graph Theory | Wikipedia”</span> (<a href="references.html#ref-wiki_graph_theory" role="doc-biblioref">2025</a>)</span>.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>See <span class="citation" data-cites="wiki_graph_glossary"><span>“Glossary of Graph Theory | Wikipedia”</span> (<a href="references.html#ref-wiki_graph_glossary" role="doc-biblioref">2025</a>)</span>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>See <span class="citation" data-cites="wiki_adjacency_matrix"><span>“Adjacency Matrix | Wikipedia”</span> (<a href="references.html#ref-wiki_adjacency_matrix" role="doc-biblioref">2025</a>)</span>.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>See <span class="citation" data-cites="wiki_degree_matrix"><span>“Degree Matrix | Wikipedia”</span> (<a href="references.html#ref-wiki_degree_matrix" role="doc-biblioref">2025</a>)</span>.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>See <span class="citation" data-cites="wiki_Laplacian_matrix"><span>“Laplacian Matrix | Wikipedia”</span> (<a href="references.html#ref-wiki_Laplacian_matrix" role="doc-biblioref">2025</a>)</span>.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>See <span class="citation" data-cites="wiki_betweenness_centrality"><span>“Betweenness Centrality | Wikipedia”</span> (<a href="references.html#ref-wiki_betweenness_centrality" role="doc-biblioref">2025</a>)</span>.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>See <span class="citation" data-cites="wiki_connected_component"><span>“Component (Graph Theory) | Wikipedia”</span> (<a href="references.html#ref-wiki_connected_component" role="doc-biblioref">2025</a>)</span>.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>See <span class="citation" data-cites="Fortunato_2010">Fortunato (<a href="references.html#ref-Fortunato_2010" role="doc-biblioref">2010</a>)</span>.<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9"><p>See <span class="citation" data-cites="wiki_PageRank"><span>“PageRank | Wikipedia”</span> (<a href="references.html#ref-wiki_PageRank" role="doc-biblioref">2025</a>)</span>.<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10"><p>We assume each node has an edge to at least one other node. This can be enforced if needed. One possibility is to remove the set <span class="math inline">\(\mathcal{N}\)</span> of those nodes <span class="math inline">\(\mathcal{n}\)</span> having no out-link to any other node, and to also remove any edges of the form <span class="math inline">\(\nu - \mathcal{n}\)</span> incident with nodes in <span class="math inline">\(\mathcal{N}\)</span>. Another possibility is to change the set of out-nodes of node <span class="math inline">\(\mathcal{n} \in \mathcal{N}\)</span> from the empty set to the singleton set <span class="math inline">\(\{ \mathcal{n} \}\)</span>.<a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11"><p>See <span class="citation" data-cites="wiki_Markov_chain"><span>“Markov Chain | Wikipedia”</span> (<a href="references.html#ref-wiki_Markov_chain" role="doc-biblioref">2025</a>)</span>.<a href="#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn12"><p>See <span class="citation" data-cites="wiki_PageRank"><span>“PageRank | Wikipedia”</span> (<a href="references.html#ref-wiki_PageRank" role="doc-biblioref">2025</a>)</span>.<a href="#fnref12" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn13"><p>See <span class="citation" data-cites="wiki_Floyd_Warshall_algo"><span>“Floyd–Warshall Algorithm | Wikipedia”</span> (<a href="references.html#ref-wiki_Floyd_Warshall_algo" role="doc-biblioref">2025</a>)</span>.<a href="#fnref13" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn14"><p>See <span class="citation" data-cites="wiki_Dijkstra_algo"><span>“Dijkstra’s Algorithm | Wikipedia”</span> (<a href="references.html#ref-wiki_Dijkstra_algo" role="doc-biblioref">2025</a>)</span>.<a href="#fnref14" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn15"><p>See <span class="citation" data-cites="wiki_Brandes_algo"><span>“Brandes’ Algorithm | Wikipedia”</span> (<a href="references.html#ref-wiki_Brandes_algo" role="doc-biblioref">2025</a>)</span>.<a href="#fnref15" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn16"><p>This formula assumes that if <span class="math inline">\((u-v) \in E\)</span>, then the <span class="math inline">\((u-v)\)</span> edge is among the shortest paths from <span class="math inline">\(u\)</span> to <span class="math inline">\(v\)</span>. If all edges have the same weight, then the <span class="math inline">\((u-v)\)</span> edge is the unique shortest path from <span class="math inline">\(u\)</span> to <span class="math inline">\(v\)</span>.<a href="#fnref16" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn17"><p>See <span class="citation" data-cites="wiki_Girvan_Newman_algo"><span>“Girvan–Newman Algorithm | Wikipedia”</span> (<a href="references.html#ref-wiki_Girvan_Newman_algo" role="doc-biblioref">2025</a>)</span>.<a href="#fnref17" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/github\.com\/tthrall\/eda4ml\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./ts-fourier.html" class="pagination-link" aria-label="Time Series Spectrum Analysis">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Time Series Spectrum Analysis</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./em-algorithm.html" class="pagination-link" aria-label="EM: the Expectation-Maximization Algorithm">
        <span class="nav-page-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">EM: the Expectation-Maximization Algorithm</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




<footer class="footer"><div class="nav-footer"><div class="nav-footer-center"><div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/tthrall/eda4ml/edit/main/graph-theory.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/tthrall/eda4ml/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></div></div></footer></body></html>